{
	"version": "https://jsonfeed.org/version/1",
	"title": "Dean W. Andreakis",
	"icon": "https://micro.blog/deanandreakis/avatar.jpg",
	"home_page_url": "https://deanware.blog/",
	"feed_url": "https://deanware.blog/feed.json",
	"items": [
		
			{
				"id": "http://deanandreakis.micro.blog/2023/06/16/rust-closures.html",
				"title": "Rust: Closures",
				"content_html": "<p>Rust closures are a powerful feature for managing data in Rust programming. They work like a function that can capture variables from the environment and use them in a block of code. You can think of them as a mini-function that can be used at runtime.</p>\n<p>One of the great things about Rust closures is that they are flexible and can be used in many different ways. For example, you can use them to implement iterators, filters, and map functions. They can also be used to implement callbacks and event handlers.</p>\n<p>Here is an example of a closure in Rust:</p>\n<div class=\"highlight\"><pre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"><code class=\"language-rust\" data-lang=\"rust\"><span style=\"color:#66d9ef\">fn</span> <span style=\"color:#a6e22e\">main</span>() {\n    <span style=\"color:#66d9ef\">let</span> a <span style=\"color:#f92672\">=</span> <span style=\"color:#ae81ff\">10</span>;\n    <span style=\"color:#66d9ef\">let</span> b <span style=\"color:#f92672\">=</span> <span style=\"color:#ae81ff\">20</span>;\n\n    <span style=\"color:#66d9ef\">let</span> add <span style=\"color:#f92672\">=</span> <span style=\"color:#f92672\">|</span>x, y<span style=\"color:#f92672\">|</span> x <span style=\"color:#f92672\">+</span> y;\n\n    <span style=\"color:#66d9ef\">let</span> result <span style=\"color:#f92672\">=</span> add(a, b);\n\n    println!(<span style=\"color:#e6db74\">&#34;The result is {}&#34;</span>, result);\n}\n</code></pre></div><p>In this code, we define a closure called &ldquo;add&rdquo; that takes two parameters and returns their sum. We then invoke the closure by passing in the values of &ldquo;a&rdquo; and &ldquo;b&rdquo; as arguments.</p>\n<p>One of the key features of Rust closures is that they can capture variables from the environment. This means that they can reference values that are declared outside of the closure. For example:</p>\n<div class=\"highlight\"><pre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"><code class=\"language-rust\" data-lang=\"rust\"><span style=\"color:#66d9ef\">fn</span> <span style=\"color:#a6e22e\">main</span>() {\n    <span style=\"color:#66d9ef\">let</span> x <span style=\"color:#f92672\">=</span> <span style=\"color:#ae81ff\">10</span>;\n    <span style=\"color:#66d9ef\">let</span> add_x <span style=\"color:#f92672\">=</span> <span style=\"color:#f92672\">|</span>y<span style=\"color:#f92672\">|</span> x <span style=\"color:#f92672\">+</span> y;\n\n    <span style=\"color:#66d9ef\">let</span> result <span style=\"color:#f92672\">=</span> add_x(<span style=\"color:#ae81ff\">20</span>);\n\n    println!(<span style=\"color:#e6db74\">&#34;The result is {}&#34;</span>, result);\n}\n</code></pre></div><p>In this code, we define a closure called &ldquo;add_x&rdquo; that takes one parameter and adds it to the value of &ldquo;x&rdquo;. &ldquo;x&rdquo; is declared outside of the closure, but the closure can still access and use its value.</p>\n<p>Rust closures can also be used to implement iterators. For example:</p>\n<div class=\"highlight\"><pre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"><code class=\"language-rust\" data-lang=\"rust\"><span style=\"color:#66d9ef\">fn</span> <span style=\"color:#a6e22e\">main</span>() {\n    <span style=\"color:#66d9ef\">let</span> v <span style=\"color:#f92672\">=</span> vec![<span style=\"color:#ae81ff\">1</span>, <span style=\"color:#ae81ff\">2</span>, <span style=\"color:#ae81ff\">3</span>, <span style=\"color:#ae81ff\">4</span>, <span style=\"color:#ae81ff\">5</span>];\n\n    <span style=\"color:#66d9ef\">let</span> sum <span style=\"color:#f92672\">=</span> v.iter().fold(<span style=\"color:#ae81ff\">0</span>, <span style=\"color:#f92672\">|</span>acc, x<span style=\"color:#f92672\">|</span> acc <span style=\"color:#f92672\">+</span> x);\n\n    println!(<span style=\"color:#e6db74\">&#34;The sum is {}&#34;</span>, sum);\n}\n</code></pre></div><p>In this code, we define a vector &ldquo;v&rdquo; and then use the &ldquo;fold&rdquo; method to sum up its values. The closure passed to &ldquo;fold&rdquo; takes two parameters: an accumulator and the current value being iterated over. It returns the sum of these two values.</p>\n<p>In conclusion, Rust closures are a powerful feature that allows for greater flexibility and control when working with data. By capturing variables from the environment and implementing iterators, filters, and callbacks, Rust closures can be used in a wide variety of applications.</p>\n",
				"content_text": "Rust closures are a powerful feature for managing data in Rust programming. They work like a function that can capture variables from the environment and use them in a block of code. You can think of them as a mini-function that can be used at runtime.\n\nOne of the great things about Rust closures is that they are flexible and can be used in many different ways. For example, you can use them to implement iterators, filters, and map functions. They can also be used to implement callbacks and event handlers.\n\nHere is an example of a closure in Rust:\n\n```rust\nfn main() {\n    let a = 10;\n    let b = 20;\n\n    let add = |x, y| x + y;\n\n    let result = add(a, b);\n\n    println!(\"The result is {}\", result);\n}\n```\n\nIn this code, we define a closure called \"add\" that takes two parameters and returns their sum. We then invoke the closure by passing in the values of \"a\" and \"b\" as arguments.\n\nOne of the key features of Rust closures is that they can capture variables from the environment. This means that they can reference values that are declared outside of the closure. For example:\n\n```rust\nfn main() {\n    let x = 10;\n    let add_x = |y| x + y;\n\n    let result = add_x(20);\n\n    println!(\"The result is {}\", result);\n}\n```\n\nIn this code, we define a closure called \"add_x\" that takes one parameter and adds it to the value of \"x\". \"x\" is declared outside of the closure, but the closure can still access and use its value.\n\nRust closures can also be used to implement iterators. For example:\n\n```rust\nfn main() {\n    let v = vec![1, 2, 3, 4, 5];\n\n    let sum = v.iter().fold(0, |acc, x| acc + x);\n\n    println!(\"The sum is {}\", sum);\n}\n```\n\nIn this code, we define a vector \"v\" and then use the \"fold\" method to sum up its values. The closure passed to \"fold\" takes two parameters: an accumulator and the current value being iterated over. It returns the sum of these two values.\n\nIn conclusion, Rust closures are a powerful feature that allows for greater flexibility and control when working with data. By capturing variables from the environment and implementing iterators, filters, and callbacks, Rust closures can be used in a wide variety of applications.\n",
				"date_published": "2023-06-16T11:32:18-07:00",
				"url": "https://deanware.blog/2023/06/16/rust-closures.html"
			},
			{
				"id": "http://deanandreakis.micro.blog/2023/06/06/rust-generic-data.html",
				"title": "Rust: Generic Data Types",
				"content_html": "<p>Introduction:</p>\n<p>Rust is a statically typed language that is designed for systems programming. It has a strong type system that empowers developers to write safe and correct code. Rust provides the facility of generic programming through which you can create functions, structs, and enums independent of any specific data type. In this blog, we&rsquo;ll look at the fundamentals of generic data types in Rust.</p>\n<p>Generic Data Types:</p>\n<p>A generic data type is a type that is not specific to a particular data type. Instead, it can be used with any data type. Generic data types are used to create more flexible and reusable code. Rust provides two ways to define generic data types i.e., through functions and through structs.</p>\n<ol>\n<li>Generic Functions:</li>\n</ol>\n<p>Generic functions are defined using angle brackets. You can denote any type with a generic type parameter. Here&rsquo;s an example of a simple generic add-function that adds two numbers of any known type:</p>\n<div class=\"highlight\"><pre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"><code class=\"language-rust\" data-lang=\"rust\"><span style=\"color:#66d9ef\">fn</span> <span style=\"color:#a6e22e\">add</span><span style=\"color:#f92672\">&lt;</span>T<span style=\"color:#f92672\">&gt;</span>(a: <span style=\"color:#a6e22e\">T</span>, b: <span style=\"color:#a6e22e\">T</span>) -&gt; <span style=\"color:#a6e22e\">T</span> {\n    a <span style=\"color:#f92672\">+</span> b\n}\n\n<span style=\"color:#66d9ef\">fn</span> <span style=\"color:#a6e22e\">main</span>() {\n    <span style=\"color:#66d9ef\">let</span> sum <span style=\"color:#f92672\">=</span> add(<span style=\"color:#ae81ff\">4</span>, <span style=\"color:#ae81ff\">5</span>);\n    println!(<span style=\"color:#e6db74\">&#34;{}&#34;</span>, sum); <span style=\"color:#75715e\">// prints 9\n</span><span style=\"color:#75715e\"></span>}\n</code></pre></div><p>In the above code, <code>T</code> is the generic type parameter. It can be any type that can be added. In the main function, we call the add function with two integer literals. The result of adding them is assigned to <code>sum</code>. Finally, the value of <code>sum</code> is printed, which is 9, in this case.</p>\n<ol start=\"2\">\n<li>Generic Structs:</li>\n</ol>\n<p>You can also use generic data types in Rust to declare generic structs. Similar to functions, generic structs use angle brackets to denote a generic type parameter. Here&rsquo;s an example of a simple generic linked list struct:</p>\n<div class=\"highlight\"><pre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"><code class=\"language-rust\" data-lang=\"rust\"><span style=\"color:#66d9ef\">struct</span> <span style=\"color:#a6e22e\">ListNode</span><span style=\"color:#f92672\">&lt;</span>T<span style=\"color:#f92672\">&gt;</span> {\n    val: <span style=\"color:#a6e22e\">T</span>,\n    next: Option<span style=\"color:#f92672\">&lt;</span>Box<span style=\"color:#f92672\">&lt;</span>ListNode<span style=\"color:#f92672\">&lt;</span>T<span style=\"color:#f92672\">&gt;&gt;&gt;</span>,\n}\n\n<span style=\"color:#66d9ef\">impl</span><span style=\"color:#f92672\">&lt;</span>T<span style=\"color:#f92672\">&gt;</span> ListNode<span style=\"color:#f92672\">&lt;</span>T<span style=\"color:#f92672\">&gt;</span> {\n    <span style=\"color:#66d9ef\">fn</span> <span style=\"color:#a6e22e\">new</span>(val: <span style=\"color:#a6e22e\">T</span>) -&gt; <span style=\"color:#a6e22e\">Self</span> {\n        ListNode { val, next: None }\n    }\n\n    <span style=\"color:#66d9ef\">fn</span> <span style=\"color:#a6e22e\">append</span>(<span style=\"color:#f92672\">&amp;</span><span style=\"color:#66d9ef\">mut</span> self, val: <span style=\"color:#a6e22e\">T</span>) {\n        <span style=\"color:#66d9ef\">match</span> <span style=\"color:#f92672\">&amp;</span><span style=\"color:#66d9ef\">mut</span> self.next {\n            Some(next) <span style=\"color:#f92672\">=&gt;</span> next.append(val),\n            None <span style=\"color:#f92672\">=&gt;</span> self.next <span style=\"color:#f92672\">=</span> Some(Box::new(ListNode::new(val))),\n        }\n    }\n}\n\n<span style=\"color:#66d9ef\">fn</span> <span style=\"color:#a6e22e\">main</span>() {\n    <span style=\"color:#66d9ef\">let</span> <span style=\"color:#66d9ef\">mut</span> list <span style=\"color:#f92672\">=</span> ListNode::new(<span style=\"color:#ae81ff\">1</span>);\n    list.append(<span style=\"color:#ae81ff\">2</span>);\n    list.append(<span style=\"color:#ae81ff\">3</span>);\n\n    println!(<span style=\"color:#e6db74\">&#34;{:?}&#34;</span>, list); <span style=\"color:#75715e\">// prints ListNode\n</span><span style=\"color:#75715e\"></span>}\n</code></pre></div><p>In the above code, <code>T</code> is the generic type parameter. It is used to denote the type of the value stored in each node of the linked list. <code>next</code> is declared as an <code>Option&lt;Box&lt;ListNode&lt;T&gt;&gt;&gt;</code> type to allow the <code>None</code> value to be used as the <code>next</code> value of the last node.</p>\n<p>The <code>impl</code> block defines two methods. The <code>new</code> method returns a new <code>ListNode</code> with the given value and <code>next</code> set to None. The <code>append</code> method adds a new node at the end of the linked list.</p>\n<p>Finally, we create a new instance of <code>ListNode</code> with the initial value of 1. Then, we add two more values to the list using the <code>append</code> method. We print the entire linked list using the <code>{:?}</code> format specifier.</p>\n<p>Conclusion:</p>\n<p>Rust&rsquo;s generic data types provide an easy way to write flexible and reusable code. You can use them with any data type to create highly modular and maintainable programs. In this post, we have looked at using generic functions and generic structs to write Rust code that is extensible, flexible, and reusable. Try them out yourself and see the power of Rust&rsquo;s generic data types.</p>\n",
				"content_text": "Introduction:\n\nRust is a statically typed language that is designed for systems programming. It has a strong type system that empowers developers to write safe and correct code. Rust provides the facility of generic programming through which you can create functions, structs, and enums independent of any specific data type. In this blog, we'll look at the fundamentals of generic data types in Rust.\n\nGeneric Data Types:\n\nA generic data type is a type that is not specific to a particular data type. Instead, it can be used with any data type. Generic data types are used to create more flexible and reusable code. Rust provides two ways to define generic data types i.e., through functions and through structs.\n\n1. Generic Functions:\n\nGeneric functions are defined using angle brackets. You can denote any type with a generic type parameter. Here's an example of a simple generic add-function that adds two numbers of any known type:\n\n```rust\nfn add<T>(a: T, b: T) -> T {\n    a + b\n}\n\nfn main() {\n    let sum = add(4, 5);\n    println!(\"{}\", sum); // prints 9\n}\n```\n\nIn the above code, `T` is the generic type parameter. It can be any type that can be added. In the main function, we call the add function with two integer literals. The result of adding them is assigned to `sum`. Finally, the value of `sum` is printed, which is 9, in this case.\n\n2. Generic Structs:\n\nYou can also use generic data types in Rust to declare generic structs. Similar to functions, generic structs use angle brackets to denote a generic type parameter. Here's an example of a simple generic linked list struct:\n\n```rust\nstruct ListNode<T> {\n    val: T,\n    next: Option<Box<ListNode<T>>>,\n}\n\nimpl<T> ListNode<T> {\n    fn new(val: T) -> Self {\n        ListNode { val, next: None }\n    }\n\n    fn append(&mut self, val: T) {\n        match &mut self.next {\n            Some(next) => next.append(val),\n            None => self.next = Some(Box::new(ListNode::new(val))),\n        }\n    }\n}\n\nfn main() {\n    let mut list = ListNode::new(1);\n    list.append(2);\n    list.append(3);\n\n    println!(\"{:?}\", list); // prints ListNode\n}\n```\n\nIn the above code, `T` is the generic type parameter. It is used to denote the type of the value stored in each node of the linked list. `next` is declared as an `Option<Box<ListNode<T>>>` type to allow the `None` value to be used as the `next` value of the last node.\n\nThe `impl` block defines two methods. The `new` method returns a new `ListNode` with the given value and `next` set to None. The `append` method adds a new node at the end of the linked list.\n\nFinally, we create a new instance of `ListNode` with the initial value of 1. Then, we add two more values to the list using the `append` method. We print the entire linked list using the `{:?}` format specifier.\n\nConclusion:\n\nRust's generic data types provide an easy way to write flexible and reusable code. You can use them with any data type to create highly modular and maintainable programs. In this post, we have looked at using generic functions and generic structs to write Rust code that is extensible, flexible, and reusable. Try them out yourself and see the power of Rust's generic data types.\n",
				"date_published": "2023-06-06T11:00:44-07:00",
				"url": "https://deanware.blog/2023/06/06/rust-generic-data.html"
			},
			{
				"id": "http://deanandreakis.micro.blog/2023/05/31/rust-enums.html",
				"title": "Rust Enums",
				"content_html": "<p>As a software developer, you may have come across situations where you need to work with different types of data. Some of these data types may be common, while others may be unique to the problem you are trying to solve. Enums can help you define custom data types that are specific to your problem domain. This article will explain the concept of enums in Rust programming language and how you can use them in your projects.</p>\n<p>What are enums?</p>\n<p>Enums are a type that define a set of named values. Each value in the set represents a different state or variant. In Rust, enums are defined using the <code>enum</code> keyword followed by the name of the enum and a set of variants. For example, this is how you can define an enum that represents the days of the week:</p>\n<div class=\"highlight\"><pre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"><code class=\"language-rust\" data-lang=\"rust\"><span style=\"color:#66d9ef\">enum</span> <span style=\"color:#a6e22e\">Weekday</span> {\n    Monday,\n    Tuesday,\n    Wednesday,\n    Thursday,\n    Friday,\n    Saturday,\n    Sunday\n}\n</code></pre></div><p>Each value in the <code>Weekday</code> enum is a variant. You can use the enum to represent any day of the week by selecting the appropriate variant.</p>\n<p>Enums can also contain data associated with each variant. For example, you can define an enum that represents a color, with an associated RGB value for each color:</p>\n<div class=\"highlight\"><pre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"><code class=\"language-rust\" data-lang=\"rust\"><span style=\"color:#66d9ef\">enum</span> <span style=\"color:#a6e22e\">Color</span> {\n    Red(<span style=\"color:#66d9ef\">u8</span>, <span style=\"color:#66d9ef\">u8</span>, <span style=\"color:#66d9ef\">u8</span>),\n    Green(<span style=\"color:#66d9ef\">u8</span>, <span style=\"color:#66d9ef\">u8</span>, <span style=\"color:#66d9ef\">u8</span>),\n    Blue(<span style=\"color:#66d9ef\">u8</span>, <span style=\"color:#66d9ef\">u8</span>, <span style=\"color:#66d9ef\">u8</span>)\n}\n</code></pre></div><p>The <code>u8</code> values represent the red, green, and blue values for each color. You can create an instance of the <code>Color</code> enum by specifying a variant and the associated data:</p>\n<div class=\"highlight\"><pre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"><code class=\"language-rust\" data-lang=\"rust\"><span style=\"color:#66d9ef\">let</span> red <span style=\"color:#f92672\">=</span> Color::Red(<span style=\"color:#ae81ff\">255</span>, <span style=\"color:#ae81ff\">0</span>, <span style=\"color:#ae81ff\">0</span>);\n</code></pre></div><p>Using Enums in Rust</p>\n<p>Enums are useful for defining custom data types that are specific to your problem domain. For example, you may want to represent the different states of a game character, such as standing, walking, jumping, or attacking. You can define an enum to represent these states:</p>\n<div class=\"highlight\"><pre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"><code class=\"language-rust\" data-lang=\"rust\"><span style=\"color:#66d9ef\">enum</span> <span style=\"color:#a6e22e\">State</span> {\n    Standing,\n    Walking,\n    Jumping,\n    Attacking\n}\n</code></pre></div><p>You can use the enum to represent the character&rsquo;s current state:</p>\n<div class=\"highlight\"><pre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"><code class=\"language-rust\" data-lang=\"rust\"><span style=\"color:#66d9ef\">let</span> state <span style=\"color:#f92672\">=</span> State::Walking;\n</code></pre></div><p>Enums are also useful for error handling. For example, you can define an enum that represents the different types of errors that can occur in your program:</p>\n<div class=\"highlight\"><pre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"><code class=\"language-rust\" data-lang=\"rust\"><span style=\"color:#66d9ef\">enum</span> <span style=\"color:#a6e22e\">Error</span> {\n    FileNotFound,\n    InvalidInput,\n    OutOfMemory\n}\n</code></pre></div><p>You can use the enum to indicate the type of error that occurred:</p>\n<div class=\"highlight\"><pre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"><code class=\"language-rust\" data-lang=\"rust\"><span style=\"color:#66d9ef\">fn</span> <span style=\"color:#a6e22e\">open_file</span>(filename: <span style=\"color:#66d9ef\">&amp;</span><span style=\"color:#66d9ef\">str</span>) -&gt; Result<span style=\"color:#f92672\">&lt;</span>File, Error<span style=\"color:#f92672\">&gt;</span> {\n    <span style=\"color:#66d9ef\">match</span> File::open(filename) {\n        Ok(file) <span style=\"color:#f92672\">=&gt;</span> Ok(file),\n        Err(_) <span style=\"color:#f92672\">=&gt;</span> Err(Error::FileNotFound)\n    }\n}\n</code></pre></div><p>In this example, the <code>open_file</code> function returns a <code>Result</code> type that indicates whether the file was opened successfully or an error occurred. If an error occurred, the function returns an instance of the <code>Error</code> enum that indicates the type of error that occurred.</p>\n<p>Enums are also useful for defining configuration options. For example, you can define an enum to represent the different types of logging levels:</p>\n<div class=\"highlight\"><pre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"><code class=\"language-rust\" data-lang=\"rust\"><span style=\"color:#66d9ef\">enum</span> <span style=\"color:#a6e22e\">LogLevel</span> {\n    Debug,\n    Information,\n    Warning,\n    Error\n}\n</code></pre></div><p>You can use the enum to configure the logging level in your program:</p>\n<div class=\"highlight\"><pre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"><code class=\"language-rust\" data-lang=\"rust\"><span style=\"color:#66d9ef\">let</span> log_level <span style=\"color:#f92672\">=</span> LogLevel::Information;\n</code></pre></div><p>Conclusion</p>\n<p>Enums are a powerful feature in Rust programming language that allow you to define custom data types that are specific to your problem domain. With enums, you can represent a set of named values that can be used to model different states or configurations in your program. You can also use enums for error handling and for defining configuration options. By using enums effectively, you can write more expressive and maintainable code that is easier to reason about and test.</p>\n",
				"content_text": "As a software developer, you may have come across situations where you need to work with different types of data. Some of these data types may be common, while others may be unique to the problem you are trying to solve. Enums can help you define custom data types that are specific to your problem domain. This article will explain the concept of enums in Rust programming language and how you can use them in your projects.\r\n\r\nWhat are enums?\r\n\r\nEnums are a type that define a set of named values. Each value in the set represents a different state or variant. In Rust, enums are defined using the `enum` keyword followed by the name of the enum and a set of variants. For example, this is how you can define an enum that represents the days of the week:\r\n\r\n```rust\r\nenum Weekday {\r\n    Monday,\r\n    Tuesday,\r\n    Wednesday,\r\n    Thursday,\r\n    Friday,\r\n    Saturday,\r\n    Sunday\r\n}\r\n```\r\n\r\nEach value in the `Weekday` enum is a variant. You can use the enum to represent any day of the week by selecting the appropriate variant.\r\n\r\nEnums can also contain data associated with each variant. For example, you can define an enum that represents a color, with an associated RGB value for each color:\r\n\r\n```rust\r\nenum Color {\r\n    Red(u8, u8, u8),\r\n    Green(u8, u8, u8),\r\n    Blue(u8, u8, u8)\r\n}\r\n```\r\n\r\nThe `u8` values represent the red, green, and blue values for each color. You can create an instance of the `Color` enum by specifying a variant and the associated data:\r\n\r\n```rust\r\nlet red = Color::Red(255, 0, 0);\r\n```\r\n\r\nUsing Enums in Rust\r\n\r\nEnums are useful for defining custom data types that are specific to your problem domain. For example, you may want to represent the different states of a game character, such as standing, walking, jumping, or attacking. You can define an enum to represent these states:\r\n\r\n```rust\r\nenum State {\r\n    Standing,\r\n    Walking,\r\n    Jumping,\r\n    Attacking\r\n}\r\n```\r\n\r\nYou can use the enum to represent the character's current state:\r\n\r\n```rust\r\nlet state = State::Walking;\r\n```\r\n\r\nEnums are also useful for error handling. For example, you can define an enum that represents the different types of errors that can occur in your program:\r\n\r\n```rust\r\nenum Error {\r\n    FileNotFound,\r\n    InvalidInput,\r\n    OutOfMemory\r\n}\r\n```\r\n\r\nYou can use the enum to indicate the type of error that occurred:\r\n\r\n```rust\r\nfn open_file(filename: &str) -> Result<File, Error> {\r\n    match File::open(filename) {\r\n        Ok(file) => Ok(file),\r\n        Err(_) => Err(Error::FileNotFound)\r\n    }\r\n}\r\n```\r\n\r\nIn this example, the `open_file` function returns a `Result` type that indicates whether the file was opened successfully or an error occurred. If an error occurred, the function returns an instance of the `Error` enum that indicates the type of error that occurred.\r\n\r\nEnums are also useful for defining configuration options. For example, you can define an enum to represent the different types of logging levels:\r\n\r\n```rust\r\nenum LogLevel {\r\n    Debug,\r\n    Information,\r\n    Warning,\r\n    Error\r\n}\r\n```\r\n\r\nYou can use the enum to configure the logging level in your program:\r\n\r\n```rust\r\nlet log_level = LogLevel::Information;\r\n```\r\n\r\nConclusion\r\n\r\nEnums are a powerful feature in Rust programming language that allow you to define custom data types that are specific to your problem domain. With enums, you can represent a set of named values that can be used to model different states or configurations in your program. You can also use enums for error handling and for defining configuration options. By using enums effectively, you can write more expressive and maintainable code that is easier to reason about and test.\n",
				"date_published": "2023-05-31T09:40:10-07:00",
				"url": "https://deanware.blog/2023/05/31/rust-enums.html"
			},
			{
				"id": "http://deanandreakis.micro.blog/2023/05/18/rust-traits.html",
				"title": "Rust Traits",
				"content_html": "<p>Rust is a modern system programming language that has gained popularity because of its safety, performance, and reliability. One of the features that make Rust unique is the concept of traits.</p>\n<p>In Rust, traits define a set of methods that a type must implement in order to conform to the trait. They are similar to interfaces in other programming languages. By defining a set of required behavior for a type, traits make Rust feel like an object-oriented language. This allows for flexible and modular programming.</p>\n<p>Here is an example of a trait definition:</p>\n<div class=\"highlight\"><pre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"><code class=\"language-rust\" data-lang=\"rust\"><span style=\"color:#66d9ef\">trait</span> Animal {\n    <span style=\"color:#66d9ef\">fn</span> <span style=\"color:#a6e22e\">sound</span>(<span style=\"color:#f92672\">&amp;</span>self) -&gt; String;\n}\n</code></pre></div><p>This defines a trait called <code>Animal</code> that requires the implementation of a method called <code>sound</code> that returns a <code>String</code>. Now, any type that implements this trait must have a <code>sound</code> method that returns a <code>String</code>.</p>\n<p>Here is an example of a <code>Dog</code> struct that implements the <code>Animal</code> trait:</p>\n<div class=\"highlight\"><pre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"><code class=\"language-rust\" data-lang=\"rust\"><span style=\"color:#66d9ef\">struct</span> <span style=\"color:#a6e22e\">Dog</span> {\n    name: String,\n}\n\n<span style=\"color:#66d9ef\">impl</span> Animal <span style=\"color:#66d9ef\">for</span> Dog {\n    <span style=\"color:#66d9ef\">fn</span> <span style=\"color:#a6e22e\">sound</span>(<span style=\"color:#f92672\">&amp;</span>self) -&gt; String {\n        format!(<span style=\"color:#e6db74\">&#34;{} barks!&#34;</span>, self.name)\n    }\n}\n</code></pre></div><p>This defines a <code>Dog</code> struct with a <code>name</code> field and implements the <code>Animal</code> trait for it. The <code>sound</code> method for <code>Dog</code> returns a <code>String</code> that includes the dog&rsquo;s name and the sound it makes.</p>\n<p>We can then write a function that takes any type that implements the <code>Animal</code> trait and calls its <code>sound</code> method:</p>\n<div class=\"highlight\"><pre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"><code class=\"language-rust\" data-lang=\"rust\"><span style=\"color:#66d9ef\">fn</span> <span style=\"color:#a6e22e\">make_sound</span>(animal: <span style=\"color:#66d9ef\">&amp;</span><span style=\"color:#a6e22e\">dyn</span> Animal) {\n    println!(<span style=\"color:#e6db74\">&#34;{}&#34;</span>, animal.sound());\n}\n</code></pre></div><p>The <code>make_sound</code> function takes a reference to a type that implements the <code>Animal</code> trait and calls its <code>sound</code> method. It uses the <code>dyn</code> keyword to indicate that the type is dynamic and can be any type that conforms to the <code>Animal</code> trait.</p>\n<p>By using traits, we can write functions that work with any type that implements the required behavior. This makes our code more modular and reusable. We can define new types that implement existing traits or create new traits to extend our program&rsquo;s functionality.</p>\n<p>In conclusion, traits are an essential part of Rust&rsquo;s feature set, making the programming language more flexible, safe, and modular. They allow us to define a set of required behavior for types and write code that can work with any type that implements the required traits.</p>\n",
				"content_text": "Rust is a modern system programming language that has gained popularity because of its safety, performance, and reliability. One of the features that make Rust unique is the concept of traits.\n\nIn Rust, traits define a set of methods that a type must implement in order to conform to the trait. They are similar to interfaces in other programming languages. By defining a set of required behavior for a type, traits make Rust feel like an object-oriented language. This allows for flexible and modular programming.\n\nHere is an example of a trait definition:\n\n```rust\ntrait Animal {\n    fn sound(&self) -> String;\n}\n```\n\nThis defines a trait called `Animal` that requires the implementation of a method called `sound` that returns a `String`. Now, any type that implements this trait must have a `sound` method that returns a `String`.\n\nHere is an example of a `Dog` struct that implements the `Animal` trait:\n\n```rust\nstruct Dog {\n    name: String,\n}\n\nimpl Animal for Dog {\n    fn sound(&self) -> String {\n        format!(\"{} barks!\", self.name)\n    }\n}\n```\n\nThis defines a `Dog` struct with a `name` field and implements the `Animal` trait for it. The `sound` method for `Dog` returns a `String` that includes the dog's name and the sound it makes.\n\nWe can then write a function that takes any type that implements the `Animal` trait and calls its `sound` method:\n\n```rust\nfn make_sound(animal: &dyn Animal) {\n    println!(\"{}\", animal.sound());\n}\n```\n\nThe `make_sound` function takes a reference to a type that implements the `Animal` trait and calls its `sound` method. It uses the `dyn` keyword to indicate that the type is dynamic and can be any type that conforms to the `Animal` trait.\n\nBy using traits, we can write functions that work with any type that implements the required behavior. This makes our code more modular and reusable. We can define new types that implement existing traits or create new traits to extend our program's functionality.\n\nIn conclusion, traits are an essential part of Rust's feature set, making the programming language more flexible, safe, and modular. They allow us to define a set of required behavior for types and write code that can work with any type that implements the required traits.\n",
				"date_published": "2023-05-18T16:44:25-07:00",
				"url": "https://deanware.blog/2023/05/18/rust-traits.html"
			},
			{
				"id": "http://deanandreakis.micro.blog/2023/05/04/introduction-to-lifetimes.html",
				"title": "Introduction to Lifetimes in Rust",
				"content_html": "<h2 id=\"introduction\">Introduction</h2>\n<p>Lifetimes in Rust are a way for the compiler to ensure memory safety by tracking and enforcing the lifetime of a variable. Lifetimes are a way of managing memory ownership and avoiding issues like dangling pointers.</p>\n<p>In Rust, variables can be borrowed by other variables or passed by reference to functions. However, the language also needs to ensure that the borrowed variable does not outlive the owner of that variable.</p>\n<p>This is where lifetimes come in. Each variable has a specific lifetime, which is determined by its scope. The lifetime of a variable represents the duration of time in which it is valid and can be accessed.</p>\n<p>When a variable is borrowed, the compiler verifies that the lifetime of the borrowed variable is within the scope of the owner variable. If the lifetime of the borrowed variable is longer than the lifetime of the owner variable, the Rust compiler will issue an error. This prevents dangling pointers and eliminates the need for garbage collection.</p>\n<p>Lifetimes are denoted by single quotes ('), and they can be specified in function signatures, structs, and other data types. You can also use the &lsquo;static lifetime for variables that live throughout the entire lifetime of the program.</p>\n<h2 id=\"example\">Example</h2>\n<div class=\"highlight\"><pre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"><code class=\"language-rust\" data-lang=\"rust\"><span style=\"color:#66d9ef\">struct</span> <span style=\"color:#a6e22e\">Foo</span><span style=\"color:#f92672\">&lt;&#39;</span><span style=\"color:#a6e22e\">a</span><span style=\"color:#f92672\">&gt;</span> {\n    x: <span style=\"color:#66d9ef\">&amp;</span><span style=\"color:#f92672\">&#39;</span><span style=\"color:#a6e22e\">a</span> <span style=\"color:#66d9ef\">str</span>,\n}\n\n<span style=\"color:#66d9ef\">impl</span><span style=\"color:#f92672\">&lt;&#39;</span><span style=\"color:#a6e22e\">a</span><span style=\"color:#f92672\">&gt;</span> Foo<span style=\"color:#f92672\">&lt;&#39;</span><span style=\"color:#a6e22e\">a</span><span style=\"color:#f92672\">&gt;</span> {\n    <span style=\"color:#66d9ef\">fn</span> <span style=\"color:#a6e22e\">new</span>(x: <span style=\"color:#66d9ef\">&amp;</span><span style=\"color:#f92672\">&#39;</span><span style=\"color:#a6e22e\">a</span> <span style=\"color:#66d9ef\">str</span>) -&gt; <span style=\"color:#a6e22e\">Foo</span><span style=\"color:#f92672\">&lt;&#39;</span><span style=\"color:#a6e22e\">a</span><span style=\"color:#f92672\">&gt;</span> {\n        Foo {\n            x: <span style=\"color:#a6e22e\">x</span>,\n        }\n    }\n}\n</code></pre></div><p>In this example, we define a <code>Foo</code> struct that has a reference to a string slice as its only field. We use the lifetime specifier <code>'a</code> to indicate that the reference is valid for the lifetime of the <code>Foo</code> struct.</p>\n<p>There&rsquo;s a lot more to know about lifetimes in Rust, but hopefully this gives you a good starting point!</p>\n",
				"content_text": "## Introduction\nLifetimes in Rust are a way for the compiler to ensure memory safety by tracking and enforcing the lifetime of a variable. Lifetimes are a way of managing memory ownership and avoiding issues like dangling pointers.\n\nIn Rust, variables can be borrowed by other variables or passed by reference to functions. However, the language also needs to ensure that the borrowed variable does not outlive the owner of that variable.\n\nThis is where lifetimes come in. Each variable has a specific lifetime, which is determined by its scope. The lifetime of a variable represents the duration of time in which it is valid and can be accessed.\n\nWhen a variable is borrowed, the compiler verifies that the lifetime of the borrowed variable is within the scope of the owner variable. If the lifetime of the borrowed variable is longer than the lifetime of the owner variable, the Rust compiler will issue an error. This prevents dangling pointers and eliminates the need for garbage collection.\n\nLifetimes are denoted by single quotes ('), and they can be specified in function signatures, structs, and other data types. You can also use the 'static lifetime for variables that live throughout the entire lifetime of the program.\n\n## Example\n\n~~~rust\nstruct Foo<'a> {\n    x: &'a str,\n}\n\nimpl<'a> Foo<'a> {\n    fn new(x: &'a str) -> Foo<'a> {\n        Foo {\n            x: x,\n        }\n    }\n}\n~~~\n\nIn this example, we define a `Foo` struct that has a reference to a string slice as its only field. We use the lifetime specifier `'a` to indicate that the reference is valid for the lifetime of the `Foo` struct.\n\nThere's a lot more to know about lifetimes in Rust, but hopefully this gives you a good starting point!\n",
				"date_published": "2023-05-04T14:55:53-07:00",
				"url": "https://deanware.blog/2023/05/04/introduction-to-lifetimes.html"
			},
			{
				"id": "http://deanandreakis.micro.blog/2023/04/12/error-handling-in.html",
				"title": "Error Handling in Rust",
				"content_html": "<p>I am currently learning Rust and I thought it would be good to write a few posts around concepts as I learn them. In this post, I&rsquo;ll explore the basics of error handling and provide some code samples.</p>\n<h1 id=\"result-and-option-enum\">Result and Option Enum</h1>\n<p>Rust uses two primary types for error handling: the Result and Option enums. The Result type is used when a function can return either a value or an error, while the Option type is used when a function can return either a value or None.</p>\n<h2 id=\"option-enum\">Option Enum</h2>\n<p>The Option enum has two variants: Some and None. It&rsquo;s commonly used when a function may or may not return a value. For example, here&rsquo;s a function that returns an Option:</p>\n<div class=\"highlight\"><pre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"><code class=\"language-rust\" data-lang=\"rust\"><span style=\"color:#66d9ef\">fn</span> <span style=\"color:#a6e22e\">find_divisor</span>(num: <span style=\"color:#66d9ef\">i32</span>, divisor: <span style=\"color:#66d9ef\">i32</span>) -&gt; Option<span style=\"color:#f92672\">&lt;</span><span style=\"color:#66d9ef\">i32</span><span style=\"color:#f92672\">&gt;</span> {\n    <span style=\"color:#66d9ef\">if</span> num <span style=\"color:#f92672\">%</span> divisor <span style=\"color:#f92672\">==</span> <span style=\"color:#ae81ff\">0</span> {\n        Some(divisor)\n    } <span style=\"color:#66d9ef\">else</span> {\n        None\n    }\n}\n\n<span style=\"color:#66d9ef\">fn</span> <span style=\"color:#a6e22e\">main</span>() {\n    <span style=\"color:#66d9ef\">match</span> find_divisor(<span style=\"color:#ae81ff\">20</span>, <span style=\"color:#ae81ff\">4</span>) {\n        Some(divisor) <span style=\"color:#f92672\">=&gt;</span> println!(<span style=\"color:#e6db74\">&#34;The divisor is: {}&#34;</span>, divisor),\n        None <span style=\"color:#f92672\">=&gt;</span> println!(<span style=\"color:#e6db74\">&#34;No divisor found.&#34;</span>),\n    }\n}\n</code></pre></div><h2 id=\"result-enum\">Result Enum</h2>\n<p>The Result enum has two variants: Ok and Err. It&rsquo;s used when a function can return either a successful value or an error. For example, here&rsquo;s a function that returns a Result:</p>\n<div class=\"highlight\"><pre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"><code class=\"language-rust\" data-lang=\"rust\"><span style=\"color:#66d9ef\">use</span> std::num::ParseIntError;\n\n<span style=\"color:#66d9ef\">fn</span> <span style=\"color:#a6e22e\">parse_integer</span>(input: <span style=\"color:#66d9ef\">&amp;</span><span style=\"color:#66d9ef\">str</span>) -&gt; Result<span style=\"color:#f92672\">&lt;</span><span style=\"color:#66d9ef\">i32</span>, ParseIntError<span style=\"color:#f92672\">&gt;</span> {\n    input.parse::<span style=\"color:#f92672\">&lt;</span><span style=\"color:#66d9ef\">i32</span><span style=\"color:#f92672\">&gt;</span>()\n}\n\n<span style=\"color:#66d9ef\">fn</span> <span style=\"color:#a6e22e\">main</span>() {\n    <span style=\"color:#66d9ef\">match</span> parse_integer(<span style=\"color:#e6db74\">&#34;42&#34;</span>) {\n        Ok(number) <span style=\"color:#f92672\">=&gt;</span> println!(<span style=\"color:#e6db74\">&#34;The number is: {}&#34;</span>, number),\n        Err(e) <span style=\"color:#f92672\">=&gt;</span> println!(<span style=\"color:#e6db74\">&#34;Error parsing number: {}&#34;</span>, e),\n    }\n}\n</code></pre></div><h1 id=\"error-propagation-with--operator\">Error Propagation with ? Operator</h1>\n<p>Rust provides a convenient ? operator for propagating errors upwards in the call stack. When placed after an expression that returns a Result, the ? operator will return the Ok variant&rsquo;s value if successful, or return early with the Err variant. Here&rsquo;s an example:</p>\n<div class=\"highlight\"><pre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4\"><code class=\"language-rust\" data-lang=\"rust\"><span style=\"color:#66d9ef\">use</span> std::fs::File;\n<span style=\"color:#66d9ef\">use</span> std::io::Read;\n<span style=\"color:#66d9ef\">use</span> std::io;\n\n<span style=\"color:#66d9ef\">fn</span> <span style=\"color:#a6e22e\">read_file_contents</span>(filename: <span style=\"color:#66d9ef\">&amp;</span><span style=\"color:#66d9ef\">str</span>) -&gt; Result<span style=\"color:#f92672\">&lt;</span>String, io::Error<span style=\"color:#f92672\">&gt;</span> {\n    <span style=\"color:#66d9ef\">let</span> <span style=\"color:#66d9ef\">mut</span> file <span style=\"color:#f92672\">=</span> File::open(filename)<span style=\"color:#f92672\">?</span>;\n    <span style=\"color:#66d9ef\">let</span> <span style=\"color:#66d9ef\">mut</span> contents <span style=\"color:#f92672\">=</span> String::new();\n    file.read_to_string(<span style=\"color:#f92672\">&amp;</span><span style=\"color:#66d9ef\">mut</span> contents)<span style=\"color:#f92672\">?</span>;\n    Ok(contents)\n}\n\n<span style=\"color:#66d9ef\">fn</span> <span style=\"color:#a6e22e\">main</span>() {\n    <span style=\"color:#66d9ef\">match</span> read_file_contents(<span style=\"color:#e6db74\">&#34;file.txt&#34;</span>) {\n        Ok(contents) <span style=\"color:#f92672\">=&gt;</span> println!(<span style=\"color:#e6db74\">&#34;File contents: {}&#34;</span>, contents),\n        Err(e) <span style=\"color:#f92672\">=&gt;</span> println!(<span style=\"color:#e6db74\">&#34;Error reading file: {}&#34;</span>, e),\n    }\n}\n</code></pre></div><p>In this example, the ? operator allows us to propagate the error to the calling function, simplifying the error handling process.</p>\n",
				"content_text": "I am currently learning Rust and I thought it would be good to write a few posts around concepts as I learn them. In this post, I'll explore the basics of error handling and provide some code samples.\n\n# Result and Option Enum\n\nRust uses two primary types for error handling: the Result and Option enums. The Result type is used when a function can return either a value or an error, while the Option type is used when a function can return either a value or None.\n\n## Option Enum\nThe Option enum has two variants: Some and None. It's commonly used when a function may or may not return a value. For example, here's a function that returns an Option:\n\n```rust\nfn find_divisor(num: i32, divisor: i32) -> Option<i32> {\n    if num % divisor == 0 {\n        Some(divisor)\n    } else {\n        None\n    }\n}\n\nfn main() {\n    match find_divisor(20, 4) {\n        Some(divisor) => println!(\"The divisor is: {}\", divisor),\n        None => println!(\"No divisor found.\"),\n    }\n}\n```\n\n## Result Enum\nThe Result enum has two variants: Ok and Err. It's used when a function can return either a successful value or an error. For example, here's a function that returns a Result:\n\n```rust\nuse std::num::ParseIntError;\n\nfn parse_integer(input: &str) -> Result<i32, ParseIntError> {\n    input.parse::<i32>()\n}\n\nfn main() {\n    match parse_integer(\"42\") {\n        Ok(number) => println!(\"The number is: {}\", number),\n        Err(e) => println!(\"Error parsing number: {}\", e),\n    }\n}\n```\n\n# Error Propagation with ? Operator\n\nRust provides a convenient ? operator for propagating errors upwards in the call stack. When placed after an expression that returns a Result, the ? operator will return the Ok variant's value if successful, or return early with the Err variant. Here's an example:\n\n```rust\nuse std::fs::File;\nuse std::io::Read;\nuse std::io;\n\nfn read_file_contents(filename: &str) -> Result<String, io::Error> {\n    let mut file = File::open(filename)?;\n    let mut contents = String::new();\n    file.read_to_string(&mut contents)?;\n    Ok(contents)\n}\n\nfn main() {\n    match read_file_contents(\"file.txt\") {\n        Ok(contents) => println!(\"File contents: {}\", contents),\n        Err(e) => println!(\"Error reading file: {}\", e),\n    }\n}\n```\n\nIn this example, the ? operator allows us to propagate the error to the calling function, simplifying the error handling process.\n",
				"date_published": "2023-04-12T10:53:30-07:00",
				"url": "https://deanware.blog/2023/04/12/error-handling-in.html"
			},
			{
				"id": "http://deanandreakis.micro.blog/2023/04/04/rust-language-a.html",
				"title": "Rust Language: A Safer Memory Model",
				"content_html": "<h2 id=\"introduction\">Introduction</h2>\n<p>I am currently learning Rust and one of the most important concepts to understand is the memory model. Rust&rsquo;s memory model addresses common pitfalls of other languages, such as null pointer dereferences, buffer overflows, and data races, without the need for a garbage collector. Let&rsquo;s take a closer look at Rust&rsquo;s memory model.</p>\n<h2 id=\"the-ownership-system-a-core-concept\">The Ownership System: A Core Concept</h2>\n<p>At the heart of Rust&rsquo;s memory model is its ownership system, which ensures that every piece of data has a single owner. This system enforces three key rules:</p>\n<ol>\n<li>Each value in Rust has one, and only one, owner.</li>\n<li>When the owner goes out of scope, the value is automatically dropped (deallocated).</li>\n<li>A value can either have a single mutable reference or multiple immutable references, but not both.\nBy adhering to these rules, Rust effectively prevents double-frees and use-after-free vulnerabilities, which often lead to security issues in other languages.</li>\n</ol>\n<h2 id=\"borrowing-and-lifetimes-safe-access-to-data\">Borrowing and Lifetimes: Safe Access to Data</h2>\n<p>Rust&rsquo;s borrowing mechanism allows data to be temporarily accessed through references without violating ownership rules. Borrowing comes in two flavors: mutable and immutable. Immutable borrows permit multiple references to read data simultaneously, while mutable borrows allow only one reference to modify the data. These restrictions prevent data races and ensure safe concurrent access to shared resources.</p>\n<p>Lifetimes, another key concept in Rust, further enhance safety by ensuring that borrowed references never outlive the data they refer to. A lifetime is a compile-time annotation that specifies the scope of a reference. Rust&rsquo;s borrow checker verifies that these lifetimes are valid, thus preventing dangling pointers and use-after-free errors.</p>\n<h2 id=\"memory-management-without-a-garbage-collector\">Memory Management without a Garbage Collector</h2>\n<p>Unlike languages like Java or Python, Rust does not rely on a garbage collector to manage memory. Instead, Rust&rsquo;s ownership system automatically deallocates memory when a value&rsquo;s owner goes out of scope. This deterministic memory management allows for predictable performance and fine-grained control over resource usage, which is especially beneficial for low-level systems programming and real-time applications.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>Rust&rsquo;s memory model offers a unique combination of safety and performance. By leveraging ownership, borrowing, and lifetimes, we can write code that is both memory-safe and efficient, without the overhead of a garbage collector.</p>\n",
				"content_text": "## Introduction\n\nI am currently learning Rust and one of the most important concepts to understand is the memory model. Rust's memory model addresses common pitfalls of other languages, such as null pointer dereferences, buffer overflows, and data races, without the need for a garbage collector. Let's take a closer look at Rust's memory model.\n\n## The Ownership System: A Core Concept\n\nAt the heart of Rust's memory model is its ownership system, which ensures that every piece of data has a single owner. This system enforces three key rules:\n\n1. Each value in Rust has one, and only one, owner.\n2. When the owner goes out of scope, the value is automatically dropped (deallocated).\n3. A value can either have a single mutable reference or multiple immutable references, but not both.\nBy adhering to these rules, Rust effectively prevents double-frees and use-after-free vulnerabilities, which often lead to security issues in other languages.\n\n## Borrowing and Lifetimes: Safe Access to Data\n\nRust's borrowing mechanism allows data to be temporarily accessed through references without violating ownership rules. Borrowing comes in two flavors: mutable and immutable. Immutable borrows permit multiple references to read data simultaneously, while mutable borrows allow only one reference to modify the data. These restrictions prevent data races and ensure safe concurrent access to shared resources.\n\nLifetimes, another key concept in Rust, further enhance safety by ensuring that borrowed references never outlive the data they refer to. A lifetime is a compile-time annotation that specifies the scope of a reference. Rust's borrow checker verifies that these lifetimes are valid, thus preventing dangling pointers and use-after-free errors.\n\n## Memory Management without a Garbage Collector\n\nUnlike languages like Java or Python, Rust does not rely on a garbage collector to manage memory. Instead, Rust's ownership system automatically deallocates memory when a value's owner goes out of scope. This deterministic memory management allows for predictable performance and fine-grained control over resource usage, which is especially beneficial for low-level systems programming and real-time applications.\n\n## Conclusion\n\nRust's memory model offers a unique combination of safety and performance. By leveraging ownership, borrowing, and lifetimes, we can write code that is both memory-safe and efficient, without the overhead of a garbage collector.\n",
				"date_published": "2023-04-04T14:23:21-07:00",
				"url": "https://deanware.blog/2023/04/04/rust-language-a.html"
			},
			{
				"id": "http://deanandreakis.micro.blog/2023/03/28/a-day-at.html",
				
				"content_html": "<p>A day at the races! We were lucky enough to go to the Arizona Nationals NHRA event on March 25, 2023.</p>\n<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>\n",
				"content_text": "A day at the races! We were lucky enough to go to the Arizona Nationals NHRA event on March 25, 2023.\n\n<img src=\"https://cdn.uploads.micro.blog/77166/2023/301a8d650a.jpg\" width=\"450\" height=\"600\" alt=\"My family and I in the stands at the drag race in Arizona.\"><img src=\"https://cdn.uploads.micro.blog/77166/2023/f50d4be6b8.png\" width=\"600\" height=\"451\" alt=\"Two very fast funny cars going down the track at the drag race in Arizona.\">\n",
				"date_published": "2023-03-28T11:06:32-07:00",
				"url": "https://deanware.blog/2023/03/28/a-day-at.html"
			},
			{
				"id": "http://deanandreakis.micro.blog/2023/03/17/introducing-typescript.html",
				"title": "Introducing Typescript 5.0",
				"content_html": "<p>I work on a very large retail website as part of my main job and TypeScript is an integral part of the technology stack. Keeping up with technology advancements is an engaging part of my position. In this blog post, I will explore some of the most interesting new features in TypeScript 5.0:</p>\n<ol>\n<li>\n<p>Static Index Signatures\nThis feature allows developers to define a specific set of keys for an object, making it easier to catch type errors early on. With this feature, TypeScript can detect when an object is being used in a way that doesn&rsquo;t match its expected type, preventing runtime errors.</p>\n</li>\n<li>\n<p>Custom JSX Factories\nThis feature allows developers to define their own custom JSX factory functions, which can be used to render components and other elements in a more flexible and customizable way.</p>\n</li>\n<li>\n<p>Template String Type Improvements\nOne of the most significant changes is the addition of support for multiline template string types, which allows developers to define multiline strings without having to escape newlines or use concatenation.</p>\n</li>\n<li>\n<p>Improved Type Inference\nTypeScript now supports partial type argument inference, which allows developers to omit some type arguments and let TypeScript infer them based on the context. This feature can help reduce boilerplate code and make it easier to work with complex types.</p>\n</li>\n<li>\n<p>Stricter Checks for Readonly Properties\nTypeScript can detect when an object&rsquo;s readonly properties are being modified and issue an error, preventing bugs and making it easier to reason about code.</p>\n</li>\n</ol>\n<p>Microsoft is doing a good job of advancing TypeScript in ways that continue to support more error free software development.</p>\n",
				"content_text": "I work on a very large retail website as part of my main job and TypeScript is an integral part of the technology stack. Keeping up with technology advancements is an engaging part of my position. In this blog post, I will explore some of the most interesting new features in TypeScript 5.0:\r\n\r\n1. Static Index Signatures\r\nThis feature allows developers to define a specific set of keys for an object, making it easier to catch type errors early on. With this feature, TypeScript can detect when an object is being used in a way that doesn't match its expected type, preventing runtime errors.\r\n\r\n2. Custom JSX Factories\r\nThis feature allows developers to define their own custom JSX factory functions, which can be used to render components and other elements in a more flexible and customizable way.\r\n\r\n3. Template String Type Improvements\r\nOne of the most significant changes is the addition of support for multiline template string types, which allows developers to define multiline strings without having to escape newlines or use concatenation. \r\n\r\n4.  Improved Type Inference\r\nTypeScript now supports partial type argument inference, which allows developers to omit some type arguments and let TypeScript infer them based on the context. This feature can help reduce boilerplate code and make it easier to work with complex types.\r\n\r\n5. Stricter Checks for Readonly Properties\r\nTypeScript can detect when an object's readonly properties are being modified and issue an error, preventing bugs and making it easier to reason about code.\r\n\r\nMicrosoft is doing a good job of advancing TypeScript in ways that continue to support more error free software development.\n",
				"date_published": "2023-03-17T08:45:28-07:00",
				"url": "https://deanware.blog/2023/03/17/introducing-typescript.html"
			},
			{
				"id": "http://deanandreakis.micro.blog/2023/03/15/suggested-read-the.html",
				
				"content_html": "<p>Suggested Read: <a href=\"https://www.nytimes.com/2023/03/08/opinion/noam-chomsky-chatgpt-ai.html\">The False Promise of ChatGPT</a> | by Dr. Noam Chomsky | Mar, 2023 | NY Times</p>\n",
				"content_text": "Suggested Read: [The False Promise of ChatGPT](https://www.nytimes.com/2023/03/08/opinion/noam-chomsky-chatgpt-ai.html) | by Dr. Noam Chomsky | Mar, 2023 | NY Times\n",
				"date_published": "2023-03-15T14:21:38-07:00",
				"url": "https://deanware.blog/2023/03/15/suggested-read-the.html"
			},
			{
				"id": "http://deanandreakis.micro.blog/2023/03/15/grover-enjoying-the.html",
				
				"content_html": "<p> Grover enjoying the weather</p>\n<!-- raw HTML omitted -->\n",
				"content_text": " Grover enjoying the weather\n\n<img src=\"https://cdn.uploads.micro.blog/77166/2023/5709176a0e.jpg\" width=\"600\" height=\"450\" alt=\"\">\n",
				"date_published": "2023-03-15T13:37:32-07:00",
				"url": "https://deanware.blog/2023/03/15/grover-enjoying-the.html"
			},
			{
				"id": "http://deanandreakis.micro.blog/2023/02/10/tpc-phoenix-open.html",
				
				"content_html": "<p> 2023 TPC Phoenix Open</p>\n<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>\n",
				"content_text": " 2023 TPC Phoenix Open\n\n<img src=\"https://cdn.uploads.micro.blog/77166/2023/af1e2a9854.jpg\" width=\"600\" height=\"450\" alt=\"\"><img src=\"https://cdn.uploads.micro.blog/77166/2023/83ac9cb18f.jpg\" width=\"450\" height=\"600\" alt=\"\">\n",
				"date_published": "2023-02-10T13:33:50-07:00",
				"url": "https://deanware.blog/2023/02/10/tpc-phoenix-open.html"
			},
			{
				"id": "http://deanandreakis.micro.blog/2023/01/30/attended-the-barrettjackson.html",
				
				"content_html": "<p> Attended the <a href=\"https://www.barrett-jackson.com/Events/Event/Home/Scottsdale-2023/ab1e8b14-6a68-41aa-becb-8942d5d2b9fa\">Barrett-Jackson</a> car show and auction in Scottsdale AZ.</p>\n<p><!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>\n",
				"content_text": " Attended the [Barrett-Jackson](https://www.barrett-jackson.com/Events/Event/Home/Scottsdale-2023/ab1e8b14-6a68-41aa-becb-8942d5d2b9fa) car show and auction in Scottsdale AZ. \n\n<img src=\"https://cdn.uploads.micro.blog/77166/2023/9a4af32236.jpg\" width=\"450\" height=\"600\" alt=\"\"><img src=\"https://cdn.uploads.micro.blog/77166/2023/6a0e8b2920.jpg\" width=\"600\" height=\"450\" alt=\"\"><img src=\"https://cdn.uploads.micro.blog/77166/2023/8f68f0fadf.jpg\" width=\"450\" height=\"600\" alt=\"\">\n",
				"date_published": "2023-01-30T11:58:06-07:00",
				"url": "https://deanware.blog/2023/01/30/attended-the-barrettjackson.html"
			},
			{
				"id": "http://deanandreakis.micro.blog/2023/01/25/horseshoe-bend-during.html",
				
				"content_html": "<p> <a href=\"https://en.wikipedia.org/wiki/Horseshoe_Bend_(Arizona)\">Horseshoe Bend</a> during snowfall</p>\n<!-- raw HTML omitted -->\n",
				"content_text": " [Horseshoe Bend](https://en.wikipedia.org/wiki/Horseshoe_Bend_(Arizona)) during snowfall\r\n\r\n\n\n<img src=\"https://cdn.uploads.micro.blog/77166/2023/fc2a9b2a62.jpg\" width=\"600\" height=\"450\" alt=\"\">\n",
				"date_published": "2023-01-25T13:53:55-07:00",
				"url": "https://deanware.blog/2023/01/25/horseshoe-bend-during.html"
			},
			{
				"id": "http://deanandreakis.micro.blog/2023/01/24/another-beautiful-sunset.html",
				
				"content_html": "<p> Another beautiful sunset</p>\n<!-- raw HTML omitted -->\n",
				"content_text": " Another beautiful sunset\n\n<img src=\"https://cdn.uploads.micro.blog/77166/2023/2a425f70ed.jpg\" width=\"600\" height=\"353\" alt=\"\">\n",
				"date_published": "2023-01-24T09:48:31-07:00",
				"url": "https://deanware.blog/2023/01/24/another-beautiful-sunset.html"
			},
			{
				"id": "http://deanandreakis.micro.blog/2023/01/19/i-am-lucky.html",
				
				"content_html": "<p>I am lucky enough to live near an area that hosts hot air balloon rides. I wake up many mornings with this view out of my bedroom window:\n</p>\n<!-- raw HTML omitted -->\n",
				"content_text": "I am lucky enough to live near an area that hosts hot air balloon rides. I wake up many mornings with this view out of my bedroom window:\n\n\n\n<img src=\"https://cdn.uploads.micro.blog/77166/2023/96ad862885.jpg\" width=\"600\" height=\"493\" alt=\"\">\n",
				"date_published": "2023-01-19T10:12:22-07:00",
				"url": "https://deanware.blog/2023/01/19/i-am-lucky.html"
			},
			{
				"id": "http://deanandreakis.micro.blog/2023/01/18/placed-my-order.html",
				
				"content_html": "<p>Placed my order for a new M2 mac mini. I currently use a 2017 27&quot; iMac w/ a core i5 processor so this should be a major speed bump.</p>\n<!-- raw HTML omitted -->\n",
				"content_text": "Placed my order for a new M2 mac mini. I currently use a 2017 27\" iMac w/ a core i5 processor so this should be a major speed bump.\n\n\n\n<img src=\"https://cdn.uploads.micro.blog/77166/2023/b8b95e6edd.png\" width=\"600\" height=\"197\" alt=\"\">\n",
				"date_published": "2023-01-18T12:22:24-07:00",
				"url": "https://deanware.blog/2023/01/18/placed-my-order.html"
			},
			{
				"id": "http://deanandreakis.micro.blog/2023/01/17/hanging-out-with.html",
				
				"content_html": "<p>Hanging out with Grover</p>\n<!-- raw HTML omitted -->\n",
				"content_text": "Hanging out with Grover \n\n<img src=\"https://cdn.uploads.micro.blog/77166/2023/9abb4dc680.jpg\" width=\"600\" height=\"600\" alt=\"\">\n",
				"date_published": "2023-01-17T10:54:38-07:00",
				"url": "https://deanware.blog/2023/01/17/hanging-out-with.html"
			},
			{
				"id": "http://deanandreakis.micro.blog/2022/08/01/backyard-sunset.html",
				
				"content_html": "<p>Backyard sunset</p>\n<!-- raw HTML omitted -->\n",
				"content_text": "Backyard sunset\n\n<img src=\"https://deanandreakis.micro.blog/uploads/2022/2ce617622d.jpg\" width=\"600\" height=\"600\" alt=\"\" />\n",
				"date_published": "2022-07-31T19:50:03-07:00",
				"url": "https://deanware.blog/2022/08/01/backyard-sunset.html"
			}
	]
}
